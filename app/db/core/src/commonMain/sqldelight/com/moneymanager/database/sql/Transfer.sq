CREATE TABLE Transfer (
    id TEXT PRIMARY KEY NOT NULL
        CHECK (
            length(id) = 36
            AND substr(id, 9, 1) = '-'
            AND substr(id, 14, 1) = '-'
            AND substr(id, 19, 1) = '-'
            AND substr(id, 24, 1) = '-'
            AND substr(id, 15, 1) IN ('1','2','3','4','5','6','7','8')
            AND lower(substr(id, 20, 1)) IN ('8','9','a','b')
        ),
    timestamp INTEGER NOT NULL,
    description TEXT NOT NULL,
    sourceAccountId INTEGER NOT NULL,
    targetAccountId INTEGER NOT NULL,
    currencyId TEXT NOT NULL
        CHECK (
            length(currencyId) = 36
            AND substr(currencyId, 9, 1) = '-'
            AND substr(currencyId, 14, 1) = '-'
            AND substr(currencyId, 19, 1) = '-'
            AND substr(currencyId, 24, 1) = '-'
            AND substr(currencyId, 15, 1) IN ('1','2','3','4','5','6','7','8')
            AND lower(substr(currencyId, 20, 1)) IN ('8','9','a','b')
        ),
    amount INTEGER NOT NULL,
    CHECK (sourceAccountId != targetAccountId),
    FOREIGN KEY (sourceAccountId) REFERENCES Account(id) ON DELETE CASCADE,
    FOREIGN KEY (targetAccountId) REFERENCES Account(id) ON DELETE CASCADE,
    FOREIGN KEY (currencyId) REFERENCES Currency(id) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS idx_transfer_source_account ON Transfer(sourceAccountId);
CREATE INDEX IF NOT EXISTS idx_transfer_target_account ON Transfer(targetAccountId);
CREATE INDEX IF NOT EXISTS idx_transfer_currency ON Transfer(currencyId);

-- Materialized table for account balances (manually refreshed)
CREATE TABLE AccountBalanceMaterializedView (
    accountId INTEGER NOT NULL,
    currencyId TEXT NOT NULL,
    balance INTEGER NOT NULL,
    PRIMARY KEY (accountId, currencyId),
    FOREIGN KEY (accountId) REFERENCES Account(id) ON DELETE CASCADE,
    FOREIGN KEY (currencyId) REFERENCES Currency(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_account_balance_mv_account ON AccountBalanceMaterializedView(accountId);
CREATE INDEX IF NOT EXISTS idx_account_balance_mv_currency ON AccountBalanceMaterializedView(currencyId);

-- Materialized table for running balances (manually refreshed)
CREATE TABLE RunningBalanceMaterializedView (
    id TEXT NOT NULL,
    timestamp INTEGER NOT NULL,
    description TEXT NOT NULL,
    accountId INTEGER NOT NULL,
    currencyId TEXT NOT NULL,
    transactionAmount INTEGER NOT NULL,
    runningBalance INTEGER NOT NULL,
    PRIMARY KEY (id, accountId),
    FOREIGN KEY (accountId) REFERENCES Account(id) ON DELETE CASCADE,
    FOREIGN KEY (currencyId) REFERENCES Currency(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_running_balance_mv_account ON RunningBalanceMaterializedView(accountId);
CREATE INDEX IF NOT EXISTS idx_running_balance_mv_timestamp ON RunningBalanceMaterializedView(timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_running_balance_mv_account_timestamp ON RunningBalanceMaterializedView(accountId, timestamp DESC);

-- Views for computing balances (used for incremental refresh)
CREATE VIEW AccountBalanceView AS
SELECT
    accountId,
    currencyId,
    SUM(COALESCE(incoming, 0) - COALESCE(outgoing, 0)) AS balance
FROM (
    SELECT
        targetAccountId AS accountId,
        currencyId,
        SUM(amount) AS incoming,
        0 AS outgoing
    FROM Transfer
    GROUP BY targetAccountId, currencyId

    UNION ALL

    SELECT
        sourceAccountId AS accountId,
        currencyId,
        0 AS incoming,
        SUM(amount) AS outgoing
    FROM Transfer
    GROUP BY sourceAccountId, currencyId
)
GROUP BY accountId, currencyId;

CREATE VIEW RunningBalanceView AS
SELECT
    m.id,
    m.timestamp,
    m.description,
    m.accountId,
    m.currencyId,
    m.transactionAmount,
    (
        SELECT SUM(m2.transactionAmount)
        FROM (
            SELECT tr.id, tr.timestamp, tr.targetAccountId AS accountId, tr.currencyId, tr.amount AS transactionAmount
            FROM Transfer tr
            UNION ALL
            SELECT tr.id, tr.timestamp, tr.sourceAccountId AS accountId, tr.currencyId, -tr.amount AS transactionAmount
            FROM Transfer tr
        ) m2
        WHERE m2.accountId = m.accountId
          AND m2.currencyId = m.currencyId
          AND (m2.timestamp < m.timestamp OR (m2.timestamp = m.timestamp AND m2.id <= m.id))
    ) AS runningBalance
FROM (
    SELECT tr.id, tr.timestamp, tr.description, tr.targetAccountId AS accountId, tr.currencyId, tr.amount AS transactionAmount
    FROM Transfer tr
    UNION ALL
    SELECT tr.id, tr.timestamp, tr.description, tr.sourceAccountId AS accountId, tr.currencyId, -tr.amount AS transactionAmount
    FROM Transfer tr
) m;

-- Table to track pending changes for incremental refresh
CREATE TABLE PendingMaterializedViewChanges (
    accountId INTEGER NOT NULL,
    currencyId TEXT NOT NULL,
    minTimestamp INTEGER NOT NULL,
    PRIMARY KEY (accountId, currencyId),
    FOREIGN KEY (accountId) REFERENCES Account(id) ON DELETE CASCADE,
    FOREIGN KEY (currencyId) REFERENCES Currency(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_pending_changes_account ON PendingMaterializedViewChanges(accountId);
CREATE INDEX IF NOT EXISTS idx_pending_changes_currency ON PendingMaterializedViewChanges(currencyId);
CREATE INDEX IF NOT EXISTS idx_pending_changes_timestamp ON PendingMaterializedViewChanges(minTimestamp);

-- NOTE: Triggers are created at runtime via DatabaseConfig.createIncrementalRefreshTriggers()
-- SQLDelight 2.2.1 has limited trigger support, so we create them dynamically

-- Queries to manually refresh materialized views

refreshAccountBalances:
DELETE FROM AccountBalanceMaterializedView;

populateAccountBalances:
INSERT INTO AccountBalanceMaterializedView (accountId, currencyId, balance)
SELECT
    accountId,
    currencyId,
    SUM(COALESCE(incoming, 0) - COALESCE(outgoing, 0)) AS balance
FROM (
    SELECT
        targetAccountId AS accountId,
        currencyId,
        SUM(amount) AS incoming,
        0 AS outgoing
    FROM Transfer
    GROUP BY targetAccountId, currencyId

    UNION ALL

    SELECT
        sourceAccountId AS accountId,
        currencyId,
        0 AS incoming,
        SUM(amount) AS outgoing
    FROM Transfer
    GROUP BY sourceAccountId, currencyId
)
GROUP BY accountId, currencyId;

refreshRunningBalances:
DELETE FROM RunningBalanceMaterializedView;

populateRunningBalances:
INSERT INTO RunningBalanceMaterializedView (id, timestamp, description, accountId, currencyId, transactionAmount, runningBalance)
SELECT
    m.id,
    m.timestamp,
    m.description,
    m.accountId,
    m.currencyId,
    m.transactionAmount,
    (
        SELECT SUM(m2.transactionAmount)
        FROM (
            SELECT tr.id, tr.timestamp, tr.targetAccountId AS accountId, tr.currencyId, tr.amount AS transactionAmount
            FROM Transfer tr
            UNION ALL
            SELECT tr.id, tr.timestamp, tr.sourceAccountId AS accountId, tr.currencyId, -tr.amount AS transactionAmount
            FROM Transfer tr
        ) m2
        WHERE m2.accountId = m.accountId
          AND m2.currencyId = m.currencyId
          AND (m2.timestamp < m.timestamp OR (m2.timestamp = m.timestamp AND m2.id <= m.id))
    ) AS runningBalance
FROM (
    SELECT tr.id, tr.timestamp, tr.description, tr.targetAccountId AS accountId, tr.currencyId, tr.amount AS transactionAmount
    FROM Transfer tr
    UNION ALL
    SELECT tr.id, tr.timestamp, tr.description, tr.sourceAccountId AS accountId, tr.currencyId, -tr.amount AS transactionAmount
    FROM Transfer tr
) m;

-- Incremental refresh queries

incrementalRefreshAccountBalances:
DELETE FROM AccountBalanceMaterializedView
WHERE (accountId, currencyId) IN (
    SELECT accountId, currencyId FROM PendingMaterializedViewChanges
);

incrementalPopulateAccountBalances:
INSERT INTO AccountBalanceMaterializedView (accountId, currencyId, balance)
SELECT
    v.accountId,
    v.currencyId,
    v.balance
FROM AccountBalanceView v
INNER JOIN PendingMaterializedViewChanges p
    ON v.accountId = p.accountId AND v.currencyId = p.currencyId;

incrementalRefreshRunningBalances:
DELETE FROM RunningBalanceMaterializedView
WHERE (accountId, currencyId) IN (
    SELECT accountId, currencyId FROM PendingMaterializedViewChanges
)
AND timestamp >= (
    SELECT minTimestamp
    FROM PendingMaterializedViewChanges p
    WHERE p.accountId = RunningBalanceMaterializedView.accountId
      AND p.currencyId = RunningBalanceMaterializedView.currencyId
);

incrementalPopulateRunningBalances:
INSERT INTO RunningBalanceMaterializedView (id, timestamp, description, accountId, currencyId, transactionAmount, runningBalance)
SELECT
    v.id,
    v.timestamp,
    v.description,
    v.accountId,
    v.currencyId,
    v.transactionAmount,
    v.runningBalance
FROM RunningBalanceView v
INNER JOIN PendingMaterializedViewChanges p
    ON v.accountId = p.accountId AND v.currencyId = p.currencyId
WHERE v.timestamp >= p.minTimestamp;

clearPendingChanges:
DELETE FROM PendingMaterializedViewChanges;

selectAll:
SELECT
    Transfer.*,
    Currency.id AS currency_id,
    Currency.code AS currency_code,
    Currency.name AS currency_name,
    Currency.scaleFactor AS currency_scaleFactor
FROM Transfer
JOIN Currency ON Transfer.currencyId = Currency.id
ORDER BY timestamp DESC;

selectById:
SELECT
    Transfer.*,
    Currency.id AS currency_id,
    Currency.code AS currency_code,
    Currency.name AS currency_name,
    Currency.scaleFactor AS currency_scaleFactor
FROM Transfer
JOIN Currency ON Transfer.currencyId = Currency.id
WHERE Transfer.id = ?;

selectByAccount:
SELECT
    Transfer.*,
    Currency.id AS currency_id,
    Currency.code AS currency_code,
    Currency.name AS currency_name,
    Currency.scaleFactor AS currency_scaleFactor
FROM Transfer
JOIN Currency ON Transfer.currencyId = Currency.id
WHERE sourceAccountId = ? OR targetAccountId = ?
ORDER BY timestamp DESC;

selectByDateRange:
SELECT
    Transfer.*,
    Currency.id AS currency_id,
    Currency.code AS currency_code,
    Currency.name AS currency_name,
    Currency.scaleFactor AS currency_scaleFactor
FROM Transfer
JOIN Currency ON Transfer.currencyId = Currency.id
WHERE timestamp >= ? AND timestamp <= ?
ORDER BY timestamp DESC;

selectByAccountAndDateRange:
SELECT
    Transfer.*,
    Currency.id AS currency_id,
    Currency.code AS currency_code,
    Currency.name AS currency_name,
    Currency.scaleFactor AS currency_scaleFactor
FROM Transfer
JOIN Currency ON Transfer.currencyId = Currency.id
WHERE (sourceAccountId = ? OR targetAccountId = ?)
AND timestamp >= ? AND timestamp <= ?
ORDER BY timestamp DESC;

insert:
INSERT INTO Transfer(id, timestamp, description, sourceAccountId, targetAccountId, currencyId, amount)
VALUES (?, ?, ?, ?, ?, ?, ?);

update:
UPDATE Transfer
SET timestamp = ?, description = ?, sourceAccountId = ?, targetAccountId = ?, currencyId = ?, amount = ?
WHERE id = ?;

delete:
DELETE FROM Transfer WHERE id = ?;

selectAllBalances:
SELECT
    AccountBalanceMaterializedView.accountId,
    AccountBalanceMaterializedView.currencyId,
    AccountBalanceMaterializedView.balance,
    Currency.id AS currency_id,
    Currency.code AS currency_code,
    Currency.name AS currency_name,
    Currency.scaleFactor AS currency_scaleFactor
FROM AccountBalanceMaterializedView
JOIN Account ON AccountBalanceMaterializedView.accountId = Account.id
JOIN Currency ON AccountBalanceMaterializedView.currencyId = Currency.id
ORDER BY Currency.code, Account.name;

selectRunningBalanceByAccount:
SELECT
    RunningBalanceMaterializedView.id,
    RunningBalanceMaterializedView.timestamp,
    RunningBalanceMaterializedView.description,
    RunningBalanceMaterializedView.accountId,
    RunningBalanceMaterializedView.currencyId,
    RunningBalanceMaterializedView.transactionAmount,
    RunningBalanceMaterializedView.runningBalance,
    Currency.id AS currency_id,
    Currency.code AS currency_code,
    Currency.name AS currency_name,
    Currency.scaleFactor AS currency_scaleFactor,
    Transfer.sourceAccountId,
    Transfer.targetAccountId
FROM RunningBalanceMaterializedView
JOIN Currency ON RunningBalanceMaterializedView.currencyId = Currency.id
JOIN Transfer ON RunningBalanceMaterializedView.id = Transfer.id
WHERE RunningBalanceMaterializedView.accountId = ?
ORDER BY RunningBalanceMaterializedView.timestamp DESC, RunningBalanceMaterializedView.id DESC;

selectRunningBalanceByAccountPaginated:
SELECT
    RunningBalanceMaterializedView.id,
    RunningBalanceMaterializedView.timestamp,
    RunningBalanceMaterializedView.description,
    RunningBalanceMaterializedView.accountId,
    RunningBalanceMaterializedView.currencyId,
    RunningBalanceMaterializedView.transactionAmount,
    RunningBalanceMaterializedView.runningBalance,
    Currency.id AS currency_id,
    Currency.code AS currency_code,
    Currency.name AS currency_name,
    Currency.scaleFactor AS currency_scaleFactor,
    Transfer.sourceAccountId,
    Transfer.targetAccountId
FROM RunningBalanceMaterializedView
JOIN Currency ON RunningBalanceMaterializedView.currencyId = Currency.id
JOIN Transfer ON RunningBalanceMaterializedView.id = Transfer.id
WHERE RunningBalanceMaterializedView.accountId = ?
  AND ((:lastTimestamp IS NULL AND :lastId IS NULL)
       OR RunningBalanceMaterializedView.timestamp < :lastTimestamp
       OR (RunningBalanceMaterializedView.timestamp = :lastTimestamp
           AND RunningBalanceMaterializedView.id < :lastId))
ORDER BY RunningBalanceMaterializedView.timestamp DESC, RunningBalanceMaterializedView.id DESC
LIMIT ?;

-- Get the row position (0-indexed) of a transaction within an account's transaction list
-- Returns the count of transactions that come BEFORE this one (i.e., have higher timestamp or same timestamp but higher id)
getTransactionRowPosition:
SELECT COUNT(*) AS rowPosition
FROM RunningBalanceMaterializedView
WHERE accountId = :accountId
  AND (timestamp > :targetTimestamp
       OR (timestamp = :targetTimestamp AND id > :targetId));

-- Load transactions for an account with offset-based pagination
selectRunningBalanceByAccountOffset:
SELECT
    RunningBalanceMaterializedView.id,
    RunningBalanceMaterializedView.timestamp,
    RunningBalanceMaterializedView.description,
    RunningBalanceMaterializedView.accountId,
    RunningBalanceMaterializedView.currencyId,
    RunningBalanceMaterializedView.transactionAmount,
    RunningBalanceMaterializedView.runningBalance,
    Currency.id AS currency_id,
    Currency.code AS currency_code,
    Currency.name AS currency_name,
    Currency.scaleFactor AS currency_scaleFactor,
    Transfer.sourceAccountId,
    Transfer.targetAccountId
FROM RunningBalanceMaterializedView
JOIN Currency ON RunningBalanceMaterializedView.currencyId = Currency.id
JOIN Transfer ON RunningBalanceMaterializedView.id = Transfer.id
WHERE RunningBalanceMaterializedView.accountId = :accountId
ORDER BY RunningBalanceMaterializedView.timestamp DESC, RunningBalanceMaterializedView.id DESC
LIMIT :limit OFFSET :offset;

-- Get total count of transactions for an account
countTransactionsByAccount:
SELECT COUNT(*) AS count
FROM RunningBalanceMaterializedView
WHERE accountId = :accountId;

-- Test helper queries
countPendingChanges:
SELECT COUNT(*) AS count FROM PendingMaterializedViewChanges;

selectBalancesFromView:
SELECT accountId, currencyId, balance
FROM AccountBalanceView
ORDER BY accountId, currencyId;
