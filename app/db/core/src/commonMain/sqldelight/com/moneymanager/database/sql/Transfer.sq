CREATE TABLE transfer (
    id INTEGER PRIMARY KEY NOT NULL,
    revision_id INTEGER NOT NULL DEFAULT 1,
    timestamp INTEGER NOT NULL,
    description TEXT NOT NULL,
    source_account_id INTEGER NOT NULL,
    target_account_id INTEGER NOT NULL,
    currency_id INTEGER NOT NULL,
    amount INTEGER NOT NULL,
    CHECK (source_account_id != target_account_id),
    FOREIGN KEY (id) REFERENCES transaction_id(id) ON DELETE RESTRICT,
    FOREIGN KEY (source_account_id) REFERENCES account(id) ON DELETE CASCADE,
    FOREIGN KEY (target_account_id) REFERENCES account(id) ON DELETE CASCADE,
    FOREIGN KEY (currency_id) REFERENCES currency(id) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS idx_transfer_source_account ON transfer(source_account_id);
CREATE INDEX IF NOT EXISTS idx_transfer_target_account ON transfer(target_account_id);
CREATE INDEX IF NOT EXISTS idx_transfer_currency ON transfer(currency_id);

-- Materialized table for account balances (manually refreshed)
CREATE TABLE account_balance_materialized_view (
    account_id INTEGER NOT NULL,
    currency_id INTEGER NOT NULL,
    balance INTEGER NOT NULL,
    PRIMARY KEY (account_id, currency_id),
    FOREIGN KEY (account_id) REFERENCES account(id) ON DELETE CASCADE,
    FOREIGN KEY (currency_id) REFERENCES currency(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_account_balance_mv_account ON account_balance_materialized_view(account_id);
CREATE INDEX IF NOT EXISTS idx_account_balance_mv_currency ON account_balance_materialized_view(currency_id);

-- Materialized table for running balances (manually refreshed)
CREATE TABLE running_balance_materialized_view (
    id INTEGER NOT NULL,
    timestamp INTEGER NOT NULL,
    description TEXT NOT NULL,
    account_id INTEGER NOT NULL,
    currency_id INTEGER NOT NULL,
    transaction_amount INTEGER NOT NULL,
    running_balance INTEGER NOT NULL,
    PRIMARY KEY (id, account_id),
    FOREIGN KEY (account_id) REFERENCES account(id) ON DELETE CASCADE,
    FOREIGN KEY (currency_id) REFERENCES currency(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_running_balance_mv_account ON running_balance_materialized_view(account_id);
CREATE INDEX IF NOT EXISTS idx_running_balance_mv_timestamp ON running_balance_materialized_view(timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_running_balance_mv_account_timestamp ON running_balance_materialized_view(account_id, timestamp DESC);

-- Views for computing balances (used for incremental refresh)
CREATE VIEW account_balance_view AS
SELECT
    account_id,
    currency_id,
    SUM(COALESCE(incoming, 0) - COALESCE(outgoing, 0)) AS balance
FROM (
    SELECT
        target_account_id AS account_id,
        currency_id,
        SUM(amount) AS incoming,
        0 AS outgoing
    FROM transfer
    GROUP BY target_account_id, currency_id

    UNION ALL

    SELECT
        source_account_id AS account_id,
        currency_id,
        0 AS incoming,
        SUM(amount) AS outgoing
    FROM transfer
    GROUP BY source_account_id, currency_id
)
GROUP BY account_id, currency_id;

CREATE VIEW running_balance_view AS
SELECT
    m.id,
    m.timestamp,
    m.description,
    m.account_id,
    m.currency_id,
    m.transaction_amount,
    (
        SELECT SUM(m2.transaction_amount)
        FROM (
            SELECT tr.id, tr.timestamp, tr.target_account_id AS account_id, tr.currency_id, tr.amount AS transaction_amount
            FROM transfer tr
            UNION ALL
            SELECT tr.id, tr.timestamp, tr.source_account_id AS account_id, tr.currency_id, -tr.amount AS transaction_amount
            FROM transfer tr
        ) m2
        WHERE m2.account_id = m.account_id
          AND m2.currency_id = m.currency_id
          AND (m2.timestamp < m.timestamp OR (m2.timestamp = m.timestamp AND m2.id <= m.id))
    ) AS running_balance
FROM (
    SELECT tr.id, tr.timestamp, tr.description, tr.target_account_id AS account_id, tr.currency_id, tr.amount AS transaction_amount
    FROM transfer tr
    UNION ALL
    SELECT tr.id, tr.timestamp, tr.description, tr.source_account_id AS account_id, tr.currency_id, -tr.amount AS transaction_amount
    FROM transfer tr
) m;

-- Table to track pending changes for incremental refresh
CREATE TABLE pending_materialized_view_changes (
    account_id INTEGER NOT NULL,
    currency_id INTEGER NOT NULL,
    min_timestamp INTEGER NOT NULL,
    PRIMARY KEY (account_id, currency_id),
    FOREIGN KEY (account_id) REFERENCES account(id) ON DELETE CASCADE,
    FOREIGN KEY (currency_id) REFERENCES currency(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_pending_changes_account ON pending_materialized_view_changes(account_id);
CREATE INDEX IF NOT EXISTS idx_pending_changes_currency ON pending_materialized_view_changes(currency_id);
CREATE INDEX IF NOT EXISTS idx_pending_changes_timestamp ON pending_materialized_view_changes(min_timestamp);

-- NOTE: Triggers are created at runtime via DatabaseConfig.createIncrementalRefreshTriggers()
-- SQLDelight 2.2.1 has limited trigger support, so we create them dynamically

-- Queries to manually refresh materialized views

refreshAccountBalances:
DELETE FROM account_balance_materialized_view;

populateAccountBalances:
INSERT INTO account_balance_materialized_view (account_id, currency_id, balance)
SELECT
    account_id,
    currency_id,
    SUM(COALESCE(incoming, 0) - COALESCE(outgoing, 0)) AS balance
FROM (
    SELECT
        target_account_id AS account_id,
        currency_id,
        SUM(amount) AS incoming,
        0 AS outgoing
    FROM transfer
    GROUP BY target_account_id, currency_id

    UNION ALL

    SELECT
        source_account_id AS account_id,
        currency_id,
        0 AS incoming,
        SUM(amount) AS outgoing
    FROM transfer
    GROUP BY source_account_id, currency_id
)
GROUP BY account_id, currency_id;

refreshRunningBalances:
DELETE FROM running_balance_materialized_view;

populateRunningBalances:
INSERT INTO running_balance_materialized_view (id, timestamp, description, account_id, currency_id, transaction_amount, running_balance)
SELECT
    m.id,
    m.timestamp,
    m.description,
    m.account_id,
    m.currency_id,
    m.transaction_amount,
    (
        SELECT SUM(m2.transaction_amount)
        FROM (
            SELECT tr.id, tr.timestamp, tr.target_account_id AS account_id, tr.currency_id, tr.amount AS transaction_amount
            FROM transfer tr
            UNION ALL
            SELECT tr.id, tr.timestamp, tr.source_account_id AS account_id, tr.currency_id, -tr.amount AS transaction_amount
            FROM transfer tr
        ) m2
        WHERE m2.account_id = m.account_id
          AND m2.currency_id = m.currency_id
          AND (m2.timestamp < m.timestamp OR (m2.timestamp = m.timestamp AND m2.id <= m.id))
    ) AS running_balance
FROM (
    SELECT tr.id, tr.timestamp, tr.description, tr.target_account_id AS account_id, tr.currency_id, tr.amount AS transaction_amount
    FROM transfer tr
    UNION ALL
    SELECT tr.id, tr.timestamp, tr.description, tr.source_account_id AS account_id, tr.currency_id, -tr.amount AS transaction_amount
    FROM transfer tr
) m;

-- Incremental refresh queries

incrementalRefreshAccountBalances:
DELETE FROM account_balance_materialized_view
WHERE (account_id, currency_id) IN (
    SELECT account_id, currency_id FROM pending_materialized_view_changes
);

incrementalPopulateAccountBalances:
INSERT INTO account_balance_materialized_view (account_id, currency_id, balance)
SELECT
    v.account_id,
    v.currency_id,
    v.balance
FROM account_balance_view v
INNER JOIN pending_materialized_view_changes p
    ON v.account_id = p.account_id AND v.currency_id = p.currency_id;

incrementalRefreshRunningBalances:
DELETE FROM running_balance_materialized_view
WHERE (account_id, currency_id) IN (
    SELECT account_id, currency_id FROM pending_materialized_view_changes
)
AND timestamp >= (
    SELECT min_timestamp
    FROM pending_materialized_view_changes p
    WHERE p.account_id = running_balance_materialized_view.account_id
      AND p.currency_id = running_balance_materialized_view.currency_id
);

incrementalPopulateRunningBalances:
INSERT INTO running_balance_materialized_view (id, timestamp, description, account_id, currency_id, transaction_amount, running_balance)
SELECT
    v.id,
    v.timestamp,
    v.description,
    v.account_id,
    v.currency_id,
    v.transaction_amount,
    v.running_balance
FROM running_balance_view v
INNER JOIN pending_materialized_view_changes p
    ON v.account_id = p.account_id AND v.currency_id = p.currency_id
WHERE v.timestamp >= p.min_timestamp;

clearPendingChanges:
DELETE FROM pending_materialized_view_changes;

selectById:
SELECT
    transfer.id,
    transfer.revision_id,
    transfer.timestamp,
    transfer.description,
    transfer.source_account_id,
    transfer.target_account_id,
    transfer.amount,
    currency.id AS currency_id,
    currency.code AS currency_code,
    currency.name AS currency_name,
    currency.scale_factor AS currency_scale_factor
FROM transfer
JOIN currency ON transfer.currency_id = currency.id
WHERE transfer.id = ?;

selectByAccount:
SELECT
    transfer.id,
    transfer.revision_id,
    transfer.timestamp,
    transfer.description,
    transfer.source_account_id,
    transfer.target_account_id,
    transfer.amount,
    currency.id AS currency_id,
    currency.code AS currency_code,
    currency.name AS currency_name,
    currency.scale_factor AS currency_scale_factor
FROM transfer
JOIN currency ON transfer.currency_id = currency.id
WHERE source_account_id = ? OR target_account_id = ?
ORDER BY timestamp DESC;

selectByDateRange:
SELECT
    transfer.id,
    transfer.revision_id,
    transfer.timestamp,
    transfer.description,
    transfer.source_account_id,
    transfer.target_account_id,
    transfer.amount,
    currency.id AS currency_id,
    currency.code AS currency_code,
    currency.name AS currency_name,
    currency.scale_factor AS currency_scale_factor
FROM transfer
JOIN currency ON transfer.currency_id = currency.id
WHERE timestamp >= ? AND timestamp <= ?
ORDER BY timestamp DESC;

selectByAccountAndDateRange:
SELECT
    transfer.id,
    transfer.revision_id,
    transfer.timestamp,
    transfer.description,
    transfer.source_account_id,
    transfer.target_account_id,
    transfer.amount,
    currency.id AS currency_id,
    currency.code AS currency_code,
    currency.name AS currency_name,
    currency.scale_factor AS currency_scale_factor
FROM transfer
JOIN currency ON transfer.currency_id = currency.id
WHERE (source_account_id = ? OR target_account_id = ?)
AND timestamp >= ? AND timestamp <= ?
ORDER BY timestamp DESC;

insert:
INSERT INTO transfer(id, revision_id, timestamp, description, source_account_id, target_account_id, currency_id, amount)
VALUES (?, ?, ?, ?, ?, ?, ?, ?);

update:
UPDATE transfer
SET revision_id = revision_id + 1, timestamp = ?, description = ?, source_account_id = ?, target_account_id = ?, currency_id = ?, amount = ?
WHERE id = ?;

delete:
DELETE FROM transfer WHERE id = ?;

selectAllBalances:
SELECT
    account_balance_materialized_view.account_id,
    account_balance_materialized_view.currency_id,
    account_balance_materialized_view.balance,
    currency.id AS currency_id,
    currency.code AS currency_code,
    currency.name AS currency_name,
    currency.scale_factor AS currency_scale_factor
FROM account_balance_materialized_view
JOIN account ON account_balance_materialized_view.account_id = account.id
JOIN currency ON account_balance_materialized_view.currency_id = currency.id
ORDER BY currency.code, account.name;

selectRunningBalanceByAccountPaginated:
SELECT
    running_balance_materialized_view.id,
    running_balance_materialized_view.timestamp,
    running_balance_materialized_view.description,
    running_balance_materialized_view.account_id,
    running_balance_materialized_view.transaction_amount,
    running_balance_materialized_view.running_balance,
    currency.id AS currency_id,
    currency.code AS currency_code,
    currency.name AS currency_name,
    currency.scale_factor AS currency_scale_factor,
    transfer.source_account_id,
    transfer.target_account_id
FROM running_balance_materialized_view
JOIN currency ON running_balance_materialized_view.currency_id = currency.id
JOIN transfer ON running_balance_materialized_view.id = transfer.id
WHERE running_balance_materialized_view.account_id = ?
  AND ((:lastTimestamp IS NULL AND :lastId IS NULL)
       OR running_balance_materialized_view.timestamp < :lastTimestamp
       OR (running_balance_materialized_view.timestamp = :lastTimestamp
           AND running_balance_materialized_view.id < :lastId))
ORDER BY running_balance_materialized_view.timestamp DESC, running_balance_materialized_view.id DESC
LIMIT ?;

-- Load earlier transactions (backward pagination - items newer than the current first item)
-- Results are returned in ASC order (oldest first), must be reversed in code
selectRunningBalanceByAccountPaginatedBackward:
SELECT
    running_balance_materialized_view.id,
    running_balance_materialized_view.timestamp,
    running_balance_materialized_view.description,
    running_balance_materialized_view.account_id,
    running_balance_materialized_view.transaction_amount,
    running_balance_materialized_view.running_balance,
    currency.id AS currency_id,
    currency.code AS currency_code,
    currency.name AS currency_name,
    currency.scale_factor AS currency_scale_factor,
    transfer.source_account_id,
    transfer.target_account_id
FROM running_balance_materialized_view
JOIN currency ON running_balance_materialized_view.currency_id = currency.id
JOIN transfer ON running_balance_materialized_view.id = transfer.id
WHERE running_balance_materialized_view.account_id = ?
  AND (running_balance_materialized_view.timestamp > :firstTimestamp
       OR (running_balance_materialized_view.timestamp = :firstTimestamp
           AND running_balance_materialized_view.id > :firstId))
ORDER BY running_balance_materialized_view.timestamp ASC, running_balance_materialized_view.id ASC
LIMIT ?;

-- Get the row position (0-indexed) of a transaction within an account's transaction list
-- Returns the count of transactions that come BEFORE this one (i.e., have higher timestamp or same timestamp but higher id)
getTransactionRowPosition:
SELECT COUNT(*) AS row_position
FROM running_balance_materialized_view
WHERE account_id = :accountId
  AND (timestamp > :targetTimestamp
       OR (timestamp = :targetTimestamp AND id > :targetId));

-- Load transactions for an account with offset-based pagination
selectRunningBalanceByAccountOffset:
SELECT
    running_balance_materialized_view.id,
    running_balance_materialized_view.timestamp,
    running_balance_materialized_view.description,
    running_balance_materialized_view.account_id,
    running_balance_materialized_view.transaction_amount,
    running_balance_materialized_view.running_balance,
    currency.id AS currency_id,
    currency.code AS currency_code,
    currency.name AS currency_name,
    currency.scale_factor AS currency_scale_factor,
    transfer.source_account_id,
    transfer.target_account_id
FROM running_balance_materialized_view
JOIN currency ON running_balance_materialized_view.currency_id = currency.id
JOIN transfer ON running_balance_materialized_view.id = transfer.id
WHERE running_balance_materialized_view.account_id = :accountId
ORDER BY running_balance_materialized_view.timestamp DESC, running_balance_materialized_view.id DESC
LIMIT :limit OFFSET :offset;

-- Get total count of transactions for an account
countTransactionsByAccount:
SELECT COUNT(*) AS count
FROM running_balance_materialized_view
WHERE account_id = :accountId;

bumpRevisionOnly:
UPDATE transfer
SET revision_id = revision_id + 1
WHERE id = ?;
