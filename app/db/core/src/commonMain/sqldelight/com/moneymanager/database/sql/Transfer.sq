CREATE TABLE Transfer (
    id TEXT PRIMARY KEY NOT NULL
        CHECK (
            length(id) = 36
            AND substr(id, 9, 1) = '-'
            AND substr(id, 14, 1) = '-'
            AND substr(id, 19, 1) = '-'
            AND substr(id, 24, 1) = '-'
            AND substr(id, 15, 1) IN ('1','2','3','4','5','6','7','8')
            AND lower(substr(id, 20, 1)) IN ('8','9','a','b')
        ),
    timestamp INTEGER NOT NULL,
    description TEXT NOT NULL,
    sourceAccountId INTEGER NOT NULL,
    targetAccountId INTEGER NOT NULL,
    currencyId TEXT NOT NULL
        CHECK (
            length(currencyId) = 36
            AND substr(currencyId, 9, 1) = '-'
            AND substr(currencyId, 14, 1) = '-'
            AND substr(currencyId, 19, 1) = '-'
            AND substr(currencyId, 24, 1) = '-'
            AND substr(currencyId, 15, 1) IN ('1','2','3','4','5','6','7','8')
            AND lower(substr(currencyId, 20, 1)) IN ('8','9','a','b')
        ),
    amount REAL NOT NULL,
    CHECK (sourceAccountId != targetAccountId),
    FOREIGN KEY (sourceAccountId) REFERENCES Account(id) ON DELETE CASCADE,
    FOREIGN KEY (targetAccountId) REFERENCES Account(id) ON DELETE CASCADE,
    FOREIGN KEY (currencyId) REFERENCES Currency(id) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS idx_transfer_source_account ON Transfer(sourceAccountId);
CREATE INDEX IF NOT EXISTS idx_transfer_target_account ON Transfer(targetAccountId);
CREATE INDEX IF NOT EXISTS idx_transfer_currency ON Transfer(currencyId);

-- Materialized table for account balances (manually refreshed)
CREATE TABLE AccountBalanceMaterializedView (
    accountId INTEGER NOT NULL,
    currencyId TEXT NOT NULL,
    balance REAL NOT NULL,
    PRIMARY KEY (accountId, currencyId),
    FOREIGN KEY (accountId) REFERENCES Account(id) ON DELETE CASCADE,
    FOREIGN KEY (currencyId) REFERENCES Currency(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_account_balance_mv_account ON AccountBalanceMaterializedView(accountId);
CREATE INDEX IF NOT EXISTS idx_account_balance_mv_currency ON AccountBalanceMaterializedView(currencyId);

-- Materialized table for running balances (manually refreshed)
CREATE TABLE RunningBalanceMaterializedView (
    id TEXT NOT NULL,
    timestamp INTEGER NOT NULL,
    description TEXT NOT NULL,
    accountId INTEGER NOT NULL,
    currencyId TEXT NOT NULL,
    transactionAmount REAL NOT NULL,
    runningBalance REAL NOT NULL,
    PRIMARY KEY (id, accountId),
    FOREIGN KEY (accountId) REFERENCES Account(id) ON DELETE CASCADE,
    FOREIGN KEY (currencyId) REFERENCES Currency(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_running_balance_mv_account ON RunningBalanceMaterializedView(accountId);
CREATE INDEX IF NOT EXISTS idx_running_balance_mv_timestamp ON RunningBalanceMaterializedView(timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_running_balance_mv_account_timestamp ON RunningBalanceMaterializedView(accountId, timestamp DESC);

-- Views for computing balances (used for incremental refresh)
CREATE VIEW AccountBalanceView AS
SELECT
    accountId,
    currencyId,
    SUM(COALESCE(incoming, 0) - COALESCE(outgoing, 0)) AS balance
FROM (
    SELECT
        targetAccountId AS accountId,
        currencyId,
        SUM(amount) AS incoming,
        0 AS outgoing
    FROM Transfer
    GROUP BY targetAccountId, currencyId

    UNION ALL

    SELECT
        sourceAccountId AS accountId,
        currencyId,
        0 AS incoming,
        SUM(amount) AS outgoing
    FROM Transfer
    GROUP BY sourceAccountId, currencyId
)
GROUP BY accountId, currencyId;

CREATE VIEW RunningBalanceView AS
SELECT
    m.id,
    m.timestamp,
    m.description,
    m.accountId,
    m.currencyId,
    m.transactionAmount,
    (
        SELECT SUM(m2.transactionAmount)
        FROM (
            SELECT tr.id, tr.timestamp, tr.targetAccountId AS accountId, tr.currencyId, tr.amount AS transactionAmount
            FROM Transfer tr
            UNION ALL
            SELECT tr.id, tr.timestamp, tr.sourceAccountId AS accountId, tr.currencyId, -tr.amount AS transactionAmount
            FROM Transfer tr
        ) m2
        WHERE m2.accountId = m.accountId
          AND m2.currencyId = m.currencyId
          AND (m2.timestamp < m.timestamp OR (m2.timestamp = m.timestamp AND m2.id <= m.id))
    ) AS runningBalance
FROM (
    SELECT tr.id, tr.timestamp, tr.description, tr.targetAccountId AS accountId, tr.currencyId, tr.amount AS transactionAmount
    FROM Transfer tr
    UNION ALL
    SELECT tr.id, tr.timestamp, tr.description, tr.sourceAccountId AS accountId, tr.currencyId, -tr.amount AS transactionAmount
    FROM Transfer tr
) m;

-- Table to track pending changes for incremental refresh
CREATE TABLE PendingMaterializedViewChanges (
    accountId INTEGER NOT NULL,
    currencyId TEXT NOT NULL,
    minTimestamp INTEGER NOT NULL,
    PRIMARY KEY (accountId, currencyId),
    FOREIGN KEY (accountId) REFERENCES Account(id) ON DELETE CASCADE,
    FOREIGN KEY (currencyId) REFERENCES Currency(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_pending_changes_account ON PendingMaterializedViewChanges(accountId);
CREATE INDEX IF NOT EXISTS idx_pending_changes_currency ON PendingMaterializedViewChanges(currencyId);
CREATE INDEX IF NOT EXISTS idx_pending_changes_timestamp ON PendingMaterializedViewChanges(minTimestamp);

-- NOTE: Triggers are created at runtime via DatabaseConfig.createIncrementalRefreshTriggers()
-- SQLDelight 2.2.1 has limited trigger support, so we create them dynamically

-- Queries to manually refresh materialized views

refreshAccountBalances:
DELETE FROM AccountBalanceMaterializedView;

populateAccountBalances:
INSERT INTO AccountBalanceMaterializedView (accountId, currencyId, balance)
SELECT
    accountId,
    currencyId,
    SUM(COALESCE(incoming, 0) - COALESCE(outgoing, 0)) AS balance
FROM (
    SELECT
        targetAccountId AS accountId,
        currencyId,
        SUM(amount) AS incoming,
        0 AS outgoing
    FROM Transfer
    GROUP BY targetAccountId, currencyId

    UNION ALL

    SELECT
        sourceAccountId AS accountId,
        currencyId,
        0 AS incoming,
        SUM(amount) AS outgoing
    FROM Transfer
    GROUP BY sourceAccountId, currencyId
)
GROUP BY accountId, currencyId;

refreshRunningBalances:
DELETE FROM RunningBalanceMaterializedView;

populateRunningBalances:
INSERT INTO RunningBalanceMaterializedView (id, timestamp, description, accountId, currencyId, transactionAmount, runningBalance)
SELECT
    m.id,
    m.timestamp,
    m.description,
    m.accountId,
    m.currencyId,
    m.transactionAmount,
    (
        SELECT SUM(m2.transactionAmount)
        FROM (
            SELECT tr.id, tr.timestamp, tr.targetAccountId AS accountId, tr.currencyId, tr.amount AS transactionAmount
            FROM Transfer tr
            UNION ALL
            SELECT tr.id, tr.timestamp, tr.sourceAccountId AS accountId, tr.currencyId, -tr.amount AS transactionAmount
            FROM Transfer tr
        ) m2
        WHERE m2.accountId = m.accountId
          AND m2.currencyId = m.currencyId
          AND (m2.timestamp < m.timestamp OR (m2.timestamp = m.timestamp AND m2.id <= m.id))
    ) AS runningBalance
FROM (
    SELECT tr.id, tr.timestamp, tr.description, tr.targetAccountId AS accountId, tr.currencyId, tr.amount AS transactionAmount
    FROM Transfer tr
    UNION ALL
    SELECT tr.id, tr.timestamp, tr.description, tr.sourceAccountId AS accountId, tr.currencyId, -tr.amount AS transactionAmount
    FROM Transfer tr
) m;

-- Incremental refresh queries

incrementalRefreshAccountBalances:
DELETE FROM AccountBalanceMaterializedView
WHERE (accountId, currencyId) IN (
    SELECT accountId, currencyId FROM PendingMaterializedViewChanges
);

incrementalPopulateAccountBalances:
INSERT INTO AccountBalanceMaterializedView (accountId, currencyId, balance)
SELECT
    v.accountId,
    v.currencyId,
    v.balance
FROM AccountBalanceView v
INNER JOIN PendingMaterializedViewChanges p
    ON v.accountId = p.accountId AND v.currencyId = p.currencyId;

incrementalRefreshRunningBalances:
DELETE FROM RunningBalanceMaterializedView
WHERE (accountId, currencyId) IN (
    SELECT accountId, currencyId FROM PendingMaterializedViewChanges
)
AND timestamp >= (
    SELECT minTimestamp
    FROM PendingMaterializedViewChanges p
    WHERE p.accountId = RunningBalanceMaterializedView.accountId
      AND p.currencyId = RunningBalanceMaterializedView.currencyId
);

incrementalPopulateRunningBalances:
INSERT INTO RunningBalanceMaterializedView (id, timestamp, description, accountId, currencyId, transactionAmount, runningBalance)
SELECT
    v.id,
    v.timestamp,
    v.description,
    v.accountId,
    v.currencyId,
    v.transactionAmount,
    v.runningBalance
FROM RunningBalanceView v
INNER JOIN PendingMaterializedViewChanges p
    ON v.accountId = p.accountId AND v.currencyId = p.currencyId
WHERE v.timestamp >= p.minTimestamp;

clearPendingChanges:
DELETE FROM PendingMaterializedViewChanges;

selectAll:
SELECT * FROM Transfer ORDER BY timestamp DESC;

selectById:
SELECT * FROM Transfer WHERE id = ?;

selectByAccount:
SELECT * FROM Transfer
WHERE sourceAccountId = ? OR targetAccountId = ?
ORDER BY timestamp DESC;

selectByDateRange:
SELECT * FROM Transfer
WHERE timestamp >= ? AND timestamp <= ?
ORDER BY timestamp DESC;

selectByAccountAndDateRange:
SELECT * FROM Transfer
WHERE (sourceAccountId = ? OR targetAccountId = ?)
AND timestamp >= ? AND timestamp <= ?
ORDER BY timestamp DESC;

insert:
INSERT INTO Transfer(id, timestamp, description, sourceAccountId, targetAccountId, currencyId, amount)
VALUES (?, ?, ?, ?, ?, ?, ?);

update:
UPDATE Transfer
SET timestamp = ?, description = ?, sourceAccountId = ?, targetAccountId = ?, currencyId = ?, amount = ?
WHERE id = ?;

delete:
DELETE FROM Transfer WHERE id = ?;

selectAllBalances:
SELECT
    AccountBalanceMaterializedView.accountId,
    AccountBalanceMaterializedView.currencyId,
    AccountBalanceMaterializedView.balance
FROM AccountBalanceMaterializedView
JOIN Account ON AccountBalanceMaterializedView.accountId = Account.id
JOIN Currency ON AccountBalanceMaterializedView.currencyId = Currency.id
ORDER BY Currency.code, Account.name;

selectRunningBalanceByAccount:
SELECT * FROM RunningBalanceMaterializedView
WHERE accountId = ?
ORDER BY timestamp DESC, id DESC;

-- Test helper queries
countPendingChanges:
SELECT COUNT(*) AS count FROM PendingMaterializedViewChanges;

selectBalancesFromView:
SELECT accountId, currencyId, balance
FROM AccountBalanceView
ORDER BY accountId, currencyId;
